(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('use-context-selector'), require('proxy-compare')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'use-context-selector', 'proxy-compare'], factory) :
  (global = global || self, factory(global.reactTracked = {}, global.react, global.useContextSelector, global.proxyCompare));
})(this, (function (exports, react, useContextSelector, proxyCompare) {
  var useAffectedDebugValue = function useAffectedDebugValue(state, affected) {
    var pathList = react.useRef();
    react.useEffect(function () {
      pathList.current = proxyCompare.affectedToPathList(state, affected);
    });
    react.useDebugValue(state);
  };

  var createTrackedSelector = function createTrackedSelector(useSelector) {
    var useTrackedSelector = function useTrackedSelector() {
      var _useReducer = react.useReducer(function (c) {
        return c + 1;
      }, 0),
          forceUpdate = _useReducer[1];

      var affected = new WeakMap();
      var lastAffected = react.useRef();
      var prevState = react.useRef();
      var lastState = react.useRef();
      react.useEffect(function () {
        lastAffected.current = affected;

        if (prevState.current !== lastState.current && proxyCompare.isChanged(prevState.current, lastState.current, affected, new WeakMap())) {
          prevState.current = lastState.current;
          forceUpdate();
        }
      });
      var selector = react.useCallback(function (nextState) {
        lastState.current = nextState;

        if (prevState.current && prevState.current !== nextState && lastAffected.current && !proxyCompare.isChanged(prevState.current, nextState, lastAffected.current, new WeakMap())) {
          // not changed
          return prevState.current;
        }

        prevState.current = nextState;
        return nextState;
      }, []);
      var state = useSelector(selector);

      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useAffectedDebugValue(state, affected);
      }

      var proxyCache = react.useMemo(function () {
        return new WeakMap();
      }, []); // per-hook proxyCache

      return proxyCompare.createProxy(state, affected, proxyCache);
    };

    return useTrackedSelector;
  };

  /* eslint react/destructuring-assignment: off */
  var warningObject = new Proxy({}, {
    get: function get() {
      throw new Error('Please use <Provider>');
    },
    apply: function apply() {
      throw new Error('Please use <Provider>');
    }
  });
  var createContainer = function createContainer(useValue, concurrentMode) {
    if (concurrentMode === void 0) {
      concurrentMode = false;
    }

    var StateContext = useContextSelector.createContext(warningObject);
    var UpdateContext = react.createContext(warningObject);

    var Provider = function Provider(props) {
      var _useValue = useValue(props),
          state = _useValue[0],
          update = _useValue[1];

      return react.createElement(UpdateContext.Provider, {
        value: update
      }, react.createElement(StateContext.Provider, {
        value: state
      }, props.children));
    };

    var useSelector = function useSelector(selector) {
      var selected = useContextSelector.useContextSelector(StateContext, selector);
      react.useDebugValue(selected);
      return selected;
    };

    var useTrackedState = createTrackedSelector(useSelector);
    var useUpdate = concurrentMode ? function () {
      var contextUpdate = useContextSelector.useContextUpdate(StateContext);
      var update = react.useContext(UpdateContext);
      return react.useCallback(function () {
        var _arguments = arguments;
        var result;
        contextUpdate(function () {
          result = update.apply(void 0, [].slice.call(_arguments));
        });
        return result;
      }, [contextUpdate, update]);
    } // not concurrentMode
    : function () {
      return react.useContext(UpdateContext);
    };

    var useTracked = function useTracked() {
      return [useTrackedState(), useUpdate()];
    };

    return {
      Provider: Provider,
      useTrackedState: useTrackedState,
      useTracked: useTracked,
      useUpdate: useUpdate,
      useSelector: useSelector
    };
  };

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function memo(Component, propsAreEqual) {
    var WrappedComponent = react.forwardRef(function (props, ref) {
      Object.values(props).forEach(proxyCompare.trackMemo);
      return react.createElement(Component, _extends({}, props, {
        ref: ref
      }));
    });
    return react.memo(WrappedComponent, propsAreEqual);
  }

  Object.defineProperty(exports, 'getUntrackedObject', {
    enumerable: true,
    get: function () { return proxyCompare.getUntracked; }
  });
  exports.createContainer = createContainer;
  exports.createTrackedSelector = createTrackedSelector;
  exports.memo = memo;

}));
//# sourceMappingURL=index.umd.js.map
