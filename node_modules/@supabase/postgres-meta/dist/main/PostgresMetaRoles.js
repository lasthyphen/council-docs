"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const pg_format_1 = require("pg-format");
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
const sql_1 = require("./sql");
class PostgresMetaRoles {
    constructor(query) {
        this.query = query;
    }
    list({ includeDefaultRoles = false, includeSystemSchemas = false, limit, offset, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let sql = `
WITH roles AS (${includeDefaultRoles
                ? sql_1.rolesSql
                : `${sql_1.rolesSql} WHERE NOT (rolname IN (${constants_1.DEFAULT_ROLES.map(pg_format_1.literal).join(',')}))`}),
  grants AS (${includeSystemSchemas
                ? sql_1.grantsSql
                : `${sql_1.grantsSql} AND NOT (nc.nspname IN (${constants_1.DEFAULT_SYSTEM_SCHEMAS.map(pg_format_1.literal).join(',')}))`})
SELECT
  *,
  ${helpers_1.coalesceRowsToArray('grants', 'SELECT * FROM grants WHERE grants.grantee = roles.name')}
FROM
  roles`;
            if (limit) {
                sql = `${sql} LIMIT ${limit}`;
            }
            if (offset) {
                sql = `${sql} OFFSET ${offset}`;
            }
            return yield this.query(sql);
        });
    }
    retrieve({ id, name, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (id) {
                const sql = `${sql_1.rolesSql} WHERE oid = ${pg_format_1.literal(id)};`;
                const { data, error } = yield this.query(sql);
                if (error) {
                    return { data, error };
                }
                else if (data.length === 0) {
                    return { data: null, error: { message: `Cannot find a role with ID ${id}` } };
                }
                else {
                    return { data: data[0], error };
                }
            }
            else if (name) {
                const sql = `${sql_1.rolesSql} WHERE rolname = ${pg_format_1.literal(name)};`;
                const { data, error } = yield this.query(sql);
                if (error) {
                    return { data, error };
                }
                else if (data.length === 0) {
                    return { data: null, error: { message: `Cannot find a role named ${name}` } };
                }
                else {
                    return { data: data[0], error };
                }
            }
            else {
                return { data: null, error: { message: 'Invalid parameters on role retrieve' } };
            }
        });
    }
    create({ name, is_superuser = false, can_create_db = false, can_create_role = false, inherit_role = true, can_login = false, is_replication_role = false, can_bypass_rls = false, connection_limit = -1, password, valid_until, member_of, members, admins, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const isSuperuserClause = is_superuser ? 'SUPERUSER' : 'NOSUPERUSER';
            const canCreateDbClause = can_create_db ? 'CREATEDB' : 'NOCREATEDB';
            const canCreateRoleClause = can_create_role ? 'CREATEROLE' : 'NOCREATEROLE';
            const inheritRoleClause = inherit_role ? 'INHERIT' : 'NOINHERIT';
            const canLoginClause = can_login ? 'LOGIN' : 'NOLOGIN';
            const isReplicationRoleClause = is_replication_role ? 'REPLICATION' : 'NOREPLICATION';
            const canBypassRlsClause = can_bypass_rls ? 'BYPASSRLS' : 'NOBYPASSRLS';
            const connectionLimitClause = `CONNECTION LIMIT ${connection_limit}`;
            const passwordClause = password === undefined ? '' : `PASSWORD ${pg_format_1.literal(password)}`;
            const validUntilClause = valid_until === undefined ? '' : `VALID UNTIL ${pg_format_1.literal(valid_until)}`;
            const memberOfClause = member_of === undefined ? '' : `IN ROLE ${member_of.join(',')}`;
            const membersClause = members === undefined ? '' : `ROLE ${members.join(',')}`;
            const adminsClause = admins === undefined ? '' : `ADMIN ${admins.join(',')}`;
            const sql = `
CREATE ROLE ${pg_format_1.ident(name)}
WITH
  ${isSuperuserClause}
  ${canCreateDbClause}
  ${canCreateRoleClause}
  ${inheritRoleClause}
  ${canLoginClause}
  ${isReplicationRoleClause}
  ${canBypassRlsClause}
  ${connectionLimitClause}
  ${passwordClause}
  ${validUntilClause}
  ${memberOfClause}
  ${membersClause}
  ${adminsClause};`;
            const { error } = yield this.query(sql);
            if (error) {
                return { data: null, error };
            }
            return yield this.retrieve({ name });
        });
    }
    update(id, { name, is_superuser, can_create_db, can_create_role, inherit_role, can_login, is_replication_role, can_bypass_rls, connection_limit, password, valid_until, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: old, error } = yield this.retrieve({ id });
            if (error) {
                return { data: null, error };
            }
            const nameSql = name === undefined ? '' : `ALTER ROLE ${pg_format_1.ident(old.name)} RENAME TO ${pg_format_1.ident(name)};`;
            let isSuperuserClause = '';
            if (is_superuser !== undefined) {
                isSuperuserClause = is_superuser ? 'SUPERUSER' : 'NOSUPERUSER';
            }
            let canCreateDbClause = '';
            if (can_create_db !== undefined) {
                canCreateDbClause = can_create_db ? 'CREATEDB' : 'NOCREATEDB';
            }
            let canCreateRoleClause = '';
            if (can_create_role !== undefined) {
                canCreateRoleClause = can_create_role ? 'CREATEROLE' : 'NOCREATEROLE';
            }
            let inheritRoleClause = '';
            if (inherit_role !== undefined) {
                inheritRoleClause = inherit_role ? 'INHERIT' : 'NOINHERIT';
            }
            let canLoginClause = '';
            if (can_login !== undefined) {
                canLoginClause = can_login ? 'LOGIN' : 'NOLOGIN';
            }
            let isReplicationRoleClause = '';
            if (is_replication_role !== undefined) {
                isReplicationRoleClause = is_replication_role ? 'REPLICATION' : 'NOREPLICATION';
            }
            let canBypassRlsClause = '';
            if (can_bypass_rls !== undefined) {
                canBypassRlsClause = can_bypass_rls ? 'BYPASSRLS' : 'NOBYPASSRLS';
            }
            const connectionLimitClause = connection_limit === undefined ? '' : `CONNECTION LIMIT ${connection_limit}`;
            const passwordClause = password === undefined ? '' : `PASSWORD ${pg_format_1.literal(password)}`;
            const validUntilClause = valid_until === undefined ? '' : `VALID UNTIL ${pg_format_1.literal(valid_until)}`;
            // nameSql must be last
            const sql = `
BEGIN;
  ALTER ROLE ${pg_format_1.ident(old.name)}
    ${isSuperuserClause}
    ${canCreateDbClause}
    ${canCreateRoleClause}
    ${inheritRoleClause}
    ${canLoginClause}
    ${isReplicationRoleClause}
    ${canBypassRlsClause}
    ${connectionLimitClause}
    ${passwordClause}
    ${validUntilClause};
  ${nameSql}
COMMIT;`;
            {
                const { error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
            }
            return yield this.retrieve({ id });
        });
    }
    remove(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: role, error } = yield this.retrieve({ id });
            if (error) {
                return { data: null, error };
            }
            const sql = `DROP ROLE ${pg_format_1.ident(role.name)};`;
            {
                const { error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
            }
            return { data: role, error: null };
        });
    }
}
exports.default = PostgresMetaRoles;
//# sourceMappingURL=PostgresMetaRoles.js.map