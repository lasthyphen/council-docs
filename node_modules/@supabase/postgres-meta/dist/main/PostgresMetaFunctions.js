"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const pg_format_1 = require("pg-format");
const constants_1 = require("./constants");
const sql_1 = require("./sql");
class PostgresMetaFunctions {
    constructor(query) {
        this.query = query;
    }
    list({ includeSystemSchemas = false, limit, offset, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let sql = enrichedFunctionsSql;
            if (!includeSystemSchemas) {
                sql = `${sql} WHERE NOT (schema IN (${constants_1.DEFAULT_SYSTEM_SCHEMAS.map(pg_format_1.literal).join(',')}))`;
            }
            if (limit) {
                sql = `${sql} LIMIT ${limit}`;
            }
            if (offset) {
                sql = `${sql} OFFSET ${offset}`;
            }
            return yield this.query(sql);
        });
    }
    retrieve({ id, name, schema = 'public', args = [], }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (id) {
                const sql = `${enrichedFunctionsSql} WHERE id = ${pg_format_1.literal(id)};`;
                const { data, error } = yield this.query(sql);
                if (error) {
                    return { data, error };
                }
                else if (data.length === 0) {
                    return { data: null, error: { message: `Cannot find a function with ID ${id}` } };
                }
                else {
                    return { data: data[0], error };
                }
            }
            else if (name && schema && args) {
                const sql = this.generateRetrieveFunctionSql({ name, schema, args });
                const { data, error } = yield this.query(sql);
                if (error) {
                    return { data, error };
                }
                else if (data.length === 0) {
                    return {
                        data: null,
                        error: {
                            message: `Cannot find function "${schema}"."${name}"(${args.join(', ')})`,
                        },
                    };
                }
                else {
                    return { data: data[0], error };
                }
            }
            else {
                return { data: null, error: { message: 'Invalid parameters on function retrieve' } };
            }
        });
    }
    create({ name, schema = 'public', args = [], definition, return_type = 'void', language = 'sql', behavior = 'VOLATILE', security_definer = false, config_params = {}, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const sql = this.generateCreateFunctionSql({
                name,
                schema,
                args,
                definition,
                return_type,
                language,
                behavior,
                security_definer,
                config_params,
            });
            const { error } = yield this.query(sql);
            if (error) {
                return { data: null, error };
            }
            return yield this.retrieve({ name, schema, args });
        });
    }
    update(id, { name, schema, definition, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { data: currentFunc, error } = yield this.retrieve({ id });
            if (error) {
                return { data: null, error };
            }
            const args = currentFunc.argument_types.split(', ');
            const identityArgs = currentFunc.identity_argument_types;
            const updateDefinitionSql = typeof definition === 'string'
                ? this.generateCreateFunctionSql(Object.assign(Object.assign({}, currentFunc), { definition,
                    args, config_params: (_a = currentFunc.config_params) !== null && _a !== void 0 ? _a : {} }), { replace: true })
                : '';
            const updateNameSql = name && name !== currentFunc.name
                ? `ALTER FUNCTION ${pg_format_1.ident(currentFunc.schema)}.${pg_format_1.ident(currentFunc.name)}(${identityArgs}) RENAME TO ${pg_format_1.ident(name)};`
                : '';
            const updateSchemaSql = schema && schema !== currentFunc.schema
                ? `ALTER FUNCTION ${pg_format_1.ident(currentFunc.schema)}.${pg_format_1.ident(name || currentFunc.name)}(${identityArgs})  SET SCHEMA ${pg_format_1.ident(schema)};`
                : '';
            const sql = `
      DO LANGUAGE plpgsql $$
      BEGIN
        IF ${typeof definition === 'string' ? 'TRUE' : 'FALSE'} THEN
          ${updateDefinitionSql}

          IF (
            SELECT id
            FROM (${sql_1.functionsSql}) AS f
            WHERE f.schema = ${pg_format_1.literal(currentFunc.schema)}
            AND f.name = ${pg_format_1.literal(currentFunc.name)}
            AND f.identity_argument_types = ${pg_format_1.literal(identityArgs)}
          ) != ${id} THEN
            RAISE EXCEPTION 'Cannot find function "${currentFunc.schema}"."${currentFunc.name}"(${identityArgs})';
          END IF;
        END IF;

        ${updateNameSql}

        ${updateSchemaSql}
      END;
      $$;
    `;
            {
                const { error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
            }
            return yield this.retrieve({ id });
        });
    }
    remove(id, { cascade = false } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: func, error } = yield this.retrieve({ id });
            if (error) {
                return { data: null, error };
            }
            const sql = `DROP FUNCTION ${pg_format_1.ident(func.schema)}.${pg_format_1.ident(func.name)}
    (${func.identity_argument_types})
    ${cascade ? 'CASCADE' : 'RESTRICT'};`;
            {
                const { error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
            }
            return { data: func, error: null };
        });
    }
    generateCreateFunctionSql({ name, schema, args, definition, return_type, language, behavior, security_definer, config_params, }, { replace = false } = {}) {
        return `
      CREATE ${replace ? 'OR REPLACE' : ''} FUNCTION ${pg_format_1.ident(schema)}.${pg_format_1.ident(name)}(${(args === null || args === void 0 ? void 0 : args.join(', ')) || ''})
      RETURNS ${return_type}
      AS ${pg_format_1.literal(definition)}
      LANGUAGE ${language}
      ${behavior}
      CALLED ON NULL INPUT
      ${security_definer ? 'SECURITY DEFINER' : 'SECURITY INVOKER'}
      ${config_params
            ? Object.entries(config_params)
                .map(([param, value]) => `SET ${param} ${value[0] === 'FROM CURRENT' ? 'FROM CURRENT' : 'TO ' + value}`)
                .join('\n')
            : ''};
    `;
    }
    generateRetrieveFunctionSql({ schema, name, args, }) {
        return `${enrichedFunctionsSql} JOIN pg_proc AS p ON id = p.oid WHERE schema = ${pg_format_1.literal(schema)} AND name = ${pg_format_1.literal(name)} AND p.proargtypes::text = ${args.length
            ? `(
          SELECT STRING_AGG(type_oid::text, ' ') FROM (
            SELECT (
              split_args.arr[
                array_length(
                  split_args.arr,
                  1
                )
              ]::regtype::oid
            ) AS type_oid FROM (
              SELECT STRING_TO_ARRAY(
                UNNEST(
                  ARRAY[${args.map(pg_format_1.literal)}]
                ),
                ' '
              ) AS arr
            ) AS split_args
          ) args
    )`
            : pg_format_1.literal('')}`;
    }
}
exports.default = PostgresMetaFunctions;
const enrichedFunctionsSql = `
  WITH f AS (
    ${sql_1.functionsSql}
  )
  SELECT
    f.*
  FROM f
`;
//# sourceMappingURL=PostgresMetaFunctions.js.map