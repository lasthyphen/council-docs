"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const pg_format_1 = require("pg-format");
const sql_1 = require("./sql");
class PostgresMetaPublications {
    constructor(query) {
        this.query = query;
    }
    list({ limit, offset, }) {
        return __awaiter(this, void 0, void 0, function* () {
            let sql = sql_1.publicationsSql;
            if (limit) {
                sql = `${sql} LIMIT ${limit}`;
            }
            if (offset) {
                sql = `${sql} OFFSET ${offset}`;
            }
            return yield this.query(sql);
        });
    }
    retrieve({ id, name, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (id) {
                const sql = `${sql_1.publicationsSql} WHERE p.oid = ${pg_format_1.literal(id)};`;
                const { data, error } = yield this.query(sql);
                if (error) {
                    return { data, error };
                }
                else if (data.length === 0) {
                    return { data: null, error: { message: `Cannot find a publication with ID ${id}` } };
                }
                else {
                    return { data: data[0], error };
                }
            }
            else if (name) {
                const sql = `${sql_1.publicationsSql} WHERE p.pubname = ${pg_format_1.literal(name)};`;
                const { data, error } = yield this.query(sql);
                if (error) {
                    return { data, error };
                }
                else if (data.length === 0) {
                    return { data: null, error: { message: `Cannot find a publication named ${name}` } };
                }
                else {
                    return { data: data[0], error };
                }
            }
            else {
                return { data: null, error: { message: 'Invalid parameters on publication retrieve' } };
            }
        });
    }
    create({ name, publish_insert = false, publish_update = false, publish_delete = false, publish_truncate = false, tables, }) {
        return __awaiter(this, void 0, void 0, function* () {
            let tableClause;
            if (tables === undefined) {
                tableClause = 'FOR ALL TABLES';
            }
            else if (tables.length === 0) {
                tableClause = '';
            }
            else {
                tableClause = `FOR TABLE ${tables
                    .map((t) => {
                    if (!t.includes('.')) {
                        return pg_format_1.ident(t);
                    }
                    const [schema, ...rest] = t.split('.');
                    const table = rest.join('.');
                    return `${pg_format_1.ident(schema)}.${pg_format_1.ident(table)}`;
                })
                    .join(',')}`;
            }
            let publishOps = [];
            if (publish_insert)
                publishOps.push('insert');
            if (publish_update)
                publishOps.push('update');
            if (publish_delete)
                publishOps.push('delete');
            if (publish_truncate)
                publishOps.push('truncate');
            const sql = `
CREATE PUBLICATION ${pg_format_1.ident(name)} ${tableClause}
  WITH (publish = '${publishOps.join(',')}');`;
            const { error } = yield this.query(sql);
            if (error) {
                return { data: null, error };
            }
            return yield this.retrieve({ name });
        });
    }
    update(id, { name, owner, publish_insert, publish_update, publish_delete, publish_truncate, tables, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: old, error } = yield this.retrieve({ id });
            if (error) {
                return { data: null, error };
            }
            // Need to work around the limitations of the SQL. Can't add/drop tables from
            // a publication with FOR ALL TABLES. Can't use the SET TABLE clause without
            // at least one table.
            //
            //                              new tables
            //
            //                      | undefined |    string[]     |
            //             ---------|-----------|-----------------|
            //                 null |    ''     | 400 Bad Request |
            // old tables  ---------|-----------|-----------------|
            //             object[] |    ''     |    See below    |
            //
            //                              new tables
            //
            //                      |    []     |      [...]      |
            //             ---------|-----------|-----------------|
            //                   [] |    ''     |    SET TABLE    |
            // old tables  ---------|-----------|-----------------|
            //                [...] | DROP all  |    SET TABLE    |
            //
            let tableSql;
            if (tables === undefined) {
                tableSql = '';
            }
            else if (old.tables === null) {
                throw new Error('Tables cannot be added to or dropped from FOR ALL TABLES publications');
            }
            else if (tables.length > 0) {
                tableSql = `ALTER PUBLICATION ${pg_format_1.ident(old.name)} SET TABLE ${tables
                    .map((t) => {
                    if (!t.includes('.')) {
                        return pg_format_1.ident(t);
                    }
                    const [schema, ...rest] = t.split('.');
                    const table = rest.join('.');
                    return `${pg_format_1.ident(schema)}.${pg_format_1.ident(table)}`;
                })
                    .join(',')};`;
            }
            else if (old.tables.length === 0) {
                tableSql = '';
            }
            else {
                tableSql = `ALTER PUBLICATION ${pg_format_1.ident(old.name)} DROP TABLE ${old.tables
                    .map((table) => `${pg_format_1.ident(table.schema)}.${pg_format_1.ident(table.name)}`)
                    .join(',')};`;
            }
            let publishOps = [];
            if (publish_insert !== null && publish_insert !== void 0 ? publish_insert : old.publish_insert)
                publishOps.push('insert');
            if (publish_update !== null && publish_update !== void 0 ? publish_update : old.publish_update)
                publishOps.push('update');
            if (publish_delete !== null && publish_delete !== void 0 ? publish_delete : old.publish_delete)
                publishOps.push('delete');
            if (publish_truncate !== null && publish_truncate !== void 0 ? publish_truncate : old.publish_truncate)
                publishOps.push('truncate');
            const publishSql = `ALTER PUBLICATION ${pg_format_1.ident(old.name)} SET (publish = '${publishOps.join(',')}');`;
            const ownerSql = owner === undefined ? '' : `ALTER PUBLICATION ${pg_format_1.ident(old.name)} OWNER TO ${pg_format_1.ident(owner)};`;
            const nameSql = name === undefined || name === old.name
                ? ''
                : `ALTER PUBLICATION ${pg_format_1.ident(old.name)} RENAME TO ${pg_format_1.ident(name)};`;
            // nameSql must be last
            const sql = `BEGIN; ${tableSql} ${publishSql} ${ownerSql} ${nameSql} COMMIT;`;
            {
                const { error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
            }
            return yield this.retrieve({ id });
        });
    }
    remove(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: publication, error } = yield this.retrieve({ id });
            if (error) {
                return { data: null, error };
            }
            const sql = `DROP PUBLICATION IF EXISTS ${pg_format_1.ident(publication.name)};`;
            {
                const { error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
            }
            return { data: publication, error: null };
        });
    }
}
exports.default = PostgresMetaPublications;
//# sourceMappingURL=PostgresMetaPublications.js.map