var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ident, literal } from 'pg-format';
import { triggersSql } from './sql';
export default class PostgresMetaTriggers {
    constructor(query) {
        this.query = query;
    }
    list({ limit, offset, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let sql = enrichedTriggersSql;
            if (limit) {
                sql = `${sql} LIMIT ${limit}`;
            }
            if (offset) {
                sql = `${sql} OFFSET ${offset}`;
            }
            return yield this.query(sql);
        });
    }
    retrieve({ id, name, schema = 'public', table, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (id) {
                const sql = `${enrichedTriggersSql} WHERE id = ${literal(id)};`;
                const { data, error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
                const triggerRecord = data && data[0];
                if (triggerRecord) {
                    return { data: triggerRecord, error: null };
                }
                return { data: null, error: { message: `Cannot find a trigger with ID ${id}` } };
            }
            if (name && schema && table) {
                const sql = `${enrichedTriggersSql} WHERE name = ${literal(name)} AND schema = ${literal(schema)} AND triggers.table = ${literal(table)};`;
                const { data, error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
                const triggerRecord = data && data[0];
                if (triggerRecord) {
                    return { data: triggerRecord, error: null };
                }
                return {
                    data: null,
                    error: {
                        message: `Cannot find a trigger with name ${name} on table "${schema}"."${table}"`,
                    },
                };
            }
            return { data: null, error: { message: 'Invalid parameters on trigger retrieve' } };
        });
    }
    /**
     * Creates trigger
     *
     * @param {Object} obj - An object.
     * @param {string} obj.name - Trigger name.
     * @param {string} obj.schema - Name of schema that trigger is for.
     * @param {string} obj.table - Unqualified table, view, or foreign table name that trigger is for.
     * @param {string} obj.function_schema - Name of schema that function is for.
     * @param {string} obj.function_name - Unqualified name of the function to execute.
     * @param {('BEFORE'|'AFTER'|'INSTEAD OF')} obj.activation - Determines when function is called
     * during event occurrence.
     * @param {Array<string>} obj.events - Event(s) that will fire the trigger. Array of the following options: 'INSERT' | 'UPDATE' | 'UPDATE
     * OF column_name1,column_name2' | 'DELETE' | 'TRUNCATE'.
     * @param {('ROW'|'STATEMENT')} obj.orientation - Trigger function for every row affected by event or
     * once per statement. Defaults to 'STATEMENT'.
     * @param {string} obj.condition - Boolean expression that will trigger function.
     * For example: 'old.* IS DISTINCT FROM new.*'
     * @param {Array<string>} obj.function_args - array of arguments to be passed to function when trigger is fired.
     * For example: ['arg1', 'arg2']
     */
    create({ name, schema = 'public', table, function_schema = 'public', function_name, function_args, activation, events, orientation, condition, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const qualifiedTableName = `${ident(schema)}.${ident(table)}`;
            const qualifiedFunctionName = `${ident(function_schema)}.${ident(function_name)}`;
            const triggerEvents = events.join(' OR ');
            const triggerOrientation = orientation ? `FOR EACH ${orientation}` : '';
            const triggerCondition = condition ? `WHEN (${condition})` : '';
            const functionArgs = `${(_a = function_args === null || function_args === void 0 ? void 0 : function_args.map(literal).join(',')) !== null && _a !== void 0 ? _a : ''}`;
            const sql = `CREATE TRIGGER ${ident(name)} ${activation} ${triggerEvents} ON ${qualifiedTableName} ${triggerOrientation} ${triggerCondition} EXECUTE FUNCTION ${qualifiedFunctionName}(${functionArgs});`;
            const { error } = yield this.query(sql);
            if (error) {
                return { data: null, error };
            }
            return yield this.retrieve({
                name,
                table,
                schema,
            });
        });
    }
    update(id, { name, enabled_mode, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: old, error } = yield this.retrieve({ id });
            if (error) {
                return { data: null, error };
            }
            let enabledModeSql = '';
            switch (enabled_mode) {
                case 'ORIGIN':
                    enabledModeSql = `ALTER TABLE ${ident(old.schema)}.${ident(old.table)} ENABLE TRIGGER ${ident(old.name)};`;
                    break;
                case 'DISABLED':
                    enabledModeSql = `ALTER TABLE ${ident(old.schema)}.${ident(old.table)} DISABLE TRIGGER ${ident(old.name)};`;
                    break;
                case 'REPLICA':
                case 'ALWAYS':
                    enabledModeSql = `ALTER TABLE ${ident(old.schema)}.${ident(old.table)} ENABLE ${enabled_mode} TRIGGER ${ident(old.name)};`;
                    break;
                default:
                    break;
            }
            const nameSql = name && name !== old.name
                ? `ALTER TRIGGER ${ident(old.name)} ON ${ident(old.schema)}.${ident(old.table)} RENAME TO ${ident(name)};`
                : '';
            // updateNameSql must be last
            const sql = `BEGIN; ${enabledModeSql}; ${nameSql}; COMMIT;`;
            {
                const { error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
            }
            return yield this.retrieve({ id });
        });
    }
    remove(id, { cascade = false } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: triggerRecord, error } = yield this.retrieve({ id });
            if (error) {
                return { data: null, error };
            }
            const { name, schema, table } = triggerRecord;
            const sql = `DROP TRIGGER ${ident(name)} ON ${ident(schema)}.${ident(table)} ${cascade ? 'CASCADE' : ''};`;
            {
                const { error } = yield this.query(sql);
                if (error) {
                    return { data: null, error };
                }
            }
            return { data: triggerRecord, error: null };
        });
    }
}
const enrichedTriggersSql = `
  WITH triggers AS (
    ${triggersSql}
  )
  SELECT
    *
  FROM triggers
`;
//# sourceMappingURL=PostgresMetaTriggers.js.map