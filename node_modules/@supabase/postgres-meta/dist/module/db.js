var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { types, Pool } from 'pg';
types.setTypeParser(20, parseInt);
export const init = (config) => {
    // NOTE: Race condition could happen here: one async task may be doing
    // `pool.end()` which invalidates the pool and subsequently all existing
    // handles to `query`. Normally you might only deal with one DB so you don't
    // need to call `pool.end()`, but since the server needs this, we make a
    // compromise: if we run `query` after `pool.end()` is called (i.e. pool is
    // `null`), we temporarily create a pool and close it right after.
    let pool = new Pool(config);
    return {
        query(sql) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!pool) {
                        const pool = new Pool(config);
                        const { rows } = yield pool.query(sql);
                        yield pool.end();
                        return { data: rows, error: null };
                    }
                    const { rows } = yield pool.query(sql);
                    return { data: rows, error: null };
                }
                catch (e) {
                    return { data: null, error: { message: e.message } };
                }
            });
        },
        end() {
            return __awaiter(this, void 0, void 0, function* () {
                const _pool = pool;
                pool = null;
                // Gracefully wait for active connections to be idle, then close all
                // connections in the pool.
                if (_pool)
                    yield _pool.end();
            });
        },
    };
};
//# sourceMappingURL=db.js.map